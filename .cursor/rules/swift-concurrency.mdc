---
description: "Swift 6 엄격한 동시성 패턴, actor isolation, @MainActor 사용, async/await 모범 사례, structured concurrency, Sendable 준수. 비동기 코드, actor, 동시 작업 작업 시 적용."
globs: ["Sources/**/*.swift"]
alwaysApply: false
---

# Swift Concurrency Guidelines for InnoFlow

## Actor Isolation (Swift 6 Strict Mode)

모든 코드는 Swift 6 엄격한 동시성 규칙을 따라야 합니다. 프로젝트는 `Package.swift`에 구성된 엄격한 동시성 모드를 사용합니다.

### @MainActor for Store

`Store`는 UI 업데이트를 관리하므로 `@MainActor`로 격리되어 있습니다:

```swift
@MainActor
public final class Store<Feature: Reducer> {
    // 모든 Store 작업은 main actor에서 실행
}
```

### Effect Handling

Effect는 비동기적으로 처리되며 `Sendable`을 준수해야 합니다:

```swift
enum Effect: Sendable {
    case fetchUser
    case saveData(Data)
}

func handle(effect: Effect) async -> EffectOutput<Action> {
    switch effect {
    case .fetchUser:
        let user = try? await api.fetchUser()
        return .single(._loaded(user))
    }
}
```

## Async/Await Patterns

### Effect Output

Effect는 `EffectOutput`을 반환하여 비동기 작업 결과를 처리합니다:

```swift
func handle(effect: Effect) async -> EffectOutput<Action> {
    switch effect {
    case .fetchUser:
        // 단일 action 반환
        let user = try await api.fetchUser()
        return .single(._loaded(user))
        
    case .streamUpdates:
        // 여러 action 스트림
        return .stream(AsyncStream { continuation in
            Task {
                for await update in api.updates {
                    continuation.yield(._updateReceived(update))
                }
            }
        })
        
    case .logEvent:
        // Fire-and-forget
        analytics.log(event)
        return .none
    }
}
```

## Structured Concurrency

### Effect Task Management

`Store`는 effect task를 자동으로 관리하고 취소합니다:

```swift
// Store 내부에서:
private var effectTasks: [UUID: Task<Void, Never>] = [:]

func processEffect(_ effect: Feature.Effect) {
    let taskId = UUID()
    let task = Task { @MainActor in
        let output = await feature.handle(effect: effect)
        // output 처리...
    }
    effectTasks[taskId] = task
}

// deinit 또는 cancelAllEffects()에서 모든 task 취소
```

## Sendable Conformance

### Action and Effect Types

동시성 안전을 위해 `Action`과 `Effect`는 `Sendable`을 준수해야 합니다:

```swift
enum Action: Sendable {
    case load
    case _loaded(User)  // User도 Sendable이어야 함
}

enum Effect: Sendable {
    case fetchUser
    case saveData(Data)  // Data는 Sendable
}
```

### State Types

`State`는 주로 `@MainActor`에서만 접근되지만, 값 타입이므로 자동으로 `Sendable`입니다:

```swift
struct State: Equatable, Sendable {
    var count: Int
    var user: User?  // User가 Sendable이면 자동 Sendable
}
```

## Thread Safety

### Mutex for Effect Tasks

Effect task 저장소는 `Mutex`를 사용하여 스레드 안전하게 관리됩니다:

```swift
final class Mutex<T> {
    private var _value: T
    private let lock = NSLock()
    
    func withLock<R>(_ body: (inout T) throws -> R) rethrows -> R {
        lock.lock()
        defer { lock.unlock() }
        return try body(&_value)
    }
}
```

## Required Patterns

1. **Store는 @MainActor** - 모든 UI 업데이트는 main actor에서
2. **Effect는 async/await** - completion handler 대신 async/await 사용
3. **Sendable 준수** - Action과 Effect는 Sendable이어야 함
4. **Structured concurrency** - Task 그룹과 async let 사용
5. **자동 취소** - Effect task는 Store deinit 시 자동 취소
6. **Thread-safe storage** - Mutex를 사용한 스레드 안전 저장소

## Error Handling with Concurrency

```swift
func handle(effect: Effect) async -> EffectOutput<Action> {
    switch effect {
    case .fetchUser:
        do {
            let user = try await api.fetchUser()
            return .single(._loaded(user))
        } catch {
            return .single(._loadFailed(error.localizedDescription))
        }
    }
}
```

## Migration from GCD

프레임워크 내부에서는 GCD를 사용하지 않고 Swift Concurrency만 사용합니다:

```swift
// ❌ 사용하지 않음: GCD
DispatchQueue.main.async { ... }

// ✅ 사용: Swift Concurrency
await MainActor.run { ... }
```

모든 동시성 코드는 이러한 엄격한 동시성 가이드라인을 따라야 합니다.
